buildscript {
  repositories {
    mavenCentral()
    maven {
      url 'https://artifactory.wetransform.to/artifactory/libs-release-local'
    }
    maven {
      url 'https://artifactory.wetransform.to/artifactory/libs-snapshot-local'
    }
  }
  dependencies {
    classpath 'to.wetransform.hale:gradle-hale-plugin:2.0.0'
    classpath 'commons-io:commons-io:2.16.1'
  }
}

plugins {
  id 'distribution'
}

apply plugin: 'to.wetransform.hale'

hale {
  cliVersion = '5.3.0'
}

import org.apache.commons.io.FileUtils

/*
 * Configuration file
 */

gradle.startParameter.continueOnFailure = true

project.ext.configBasePath = project.file(project.hasProperty('configBasePath') ? project.getProperty('configBasePath') : '.')
def json = new groovy.json.JsonSlurper()
def config = json.parse(file(project.hasProperty('configFile') ? project.getProperty('configFile') : 'config.json'))

/*
 * Transformation tasks
 */

task('transform-all') {
  description 'Führt alle Transformationen durch'
  group 'Transformation'
}

task('validate-all') {
  description 'Führt alle Validierungen durch'
  group 'Validierung'
}

task('aggregate-all') {
  description 'Führt alle Aggregationen durch'
  group 'Aggregation'
}

task('prepare-validation-summary').doFirst {
  def summaryFile = file('Zusammenfassung.log')
  summaryFile.withWriterAppend('utf8') { out ->
    out.append('\n')
    out.append('==================================================\n')
    out.append("Validierungslauf ${new Date().toString()}\n")
    out.append('==================================================\n')
  }
}

config.validations.each { name, settings ->
    def projectFile = new File(configBasePath, settings.project)

    String targetName = "$name"
    File targetFolder = settings.targetFolder ? new File(configBasePath, settings.targetFolder) : new File('result', targetName)

    // File outputFolder = new File(targetFolder, 'results')

    def inputFolder = new File(configBasePath, settings.table.path)
    if (inputFolder.exists()) {
      inputFolder.eachDir { d ->

        File logFileFolder = new File(targetFolder, d.name)
        logFileFolder.mkdirs()

        task("validate-$name-${d.name}", type: hale.transform()) {
          assert projectFile != null
          transformation = projectFile

          logToConsole = false
          logFolder = logFileFolder

          if (settings.sheets) {
            settings.sheets.each { s ->
              source(d) {
                include '*.xlsx'
                provider 'eu.esdihumboldt.hale.io.xls.reader.instance'
                setting 'contentType', 'eu.esdihumboldt.hale.io.xls.xlsx'
                setting 'skip', "${s.skip}"
                setting 'sheetIndex', "${s.index}"
                setting 'typename', "${s.typename}"
                setting 'dateTimeFormatterDefault', '[dd.MM.yyyy]'
              }
            }
          }
          else {
            source(d) {
              include '*.xlsx'
              provider 'eu.esdihumboldt.hale.io.xls.reader.instance'
              setting 'contentType', 'eu.esdihumboldt.hale.io.xls.xlsx'
              setting 'skip', '0'
              setting 'multiSheet', 'true'
              setting 'dateTimeFormatterDefault', '[dd.MM.yyyy]'
            }
          }

          source(d) {
            include '*.shp'
            provider 'eu.esdihumboldt.hale.io.shape.reader.instance'
            setting 'contentType', 'eu.esdihumboldt.hale.io.shp'
            setting 'autoDetectSchemaTypes', 'false'
            setting 'typename', '{http://www.esdi-humboldt.eu/hale/shp}LAP_Ruhige_Gebiete_Lage'
          }

          source(d) {
            include '*.gpkg'
            provider 'eu.esdihumboldt.hale.io.geopackage.instance.reader'
            setting 'contentType', 'eu.esdihumboldt.hale.io.geopackage'
          }

          settings.additionalSources?.each { src ->
            def additionalSourceFolder
            if (src.folder) {
              additionalSourceFolder = new File(configBasePath, src.folder)
            }
            else {
              additionalSourceFolder = d
            }
            source(additionalSourceFolder) {
              include src.includePattern
              provider src.provider
              setting 'contentType', "${src.contentType}"
            }
          }

          target(new File(logFileFolder, settings.targetFileName ?: 'output.xlsx')) {
            preset 'default'
          }

          printStacktrace = true
          trustGroovy = true
          ignoreExitValue = false

          additionalArgs << '-statisticsOut'
          additionalArgs << "${logFileFolder}/statistics.json"
          additionalArgs << '-reportsOut'
          additionalArgs << "${logFileFolder}/reports.out"
          additionalArgs << '-successEvaluation'
          additionalArgs << 'successEvaluation.groovy'

          description "Eingabedaten auf Basis des hale»studio-Projekts \"${projectFile.name}\" validieren."
          group 'Validierung'

          dependsOn 'prepare-validation-summary'
          finalizedBy "finalize-$name-${d.name}"
        }

        tasks["validate-$name-${d.name}"].doFirst {
          targetFolder.mkdirs()
          logFileFolder.mkdirs()
          FileUtils.cleanDirectory(logFileFolder)
        }

        task("finalize-$name-${d.name}").doLast {
          def outputFile = new File(logFileFolder, 'LAP_HVS_2024_v230717_validation.xlsx')
          def renamedFile = new File(logFileFolder, "DF7_10_NAP_MajorRoads_${d.name}.xlsx")
          outputFile.renameTo(renamedFile)
        }

        tasks['validate-all'].dependsOn("validate-$name-${d.name}")
      }
    }
}

config.aggregations.each { name, settings ->
    def projectFile = new File(configBasePath, settings.project)

    String targetName = "$name"
    File targetFolder = settings.targetFolder ? new File(configBasePath, settings.targetFolder) : new File('result', targetName)

    def inputFolder = new File(configBasePath, settings.table.path)

    task("aggregate-$name", type: hale.transform()) {
      assert projectFile != null
      transformation = projectFile

      logToConsole = false
      logFolder = targetFolder

      if (inputFolder.exists()) {
        inputFolder.eachDir { d ->
          source(d) {
            include '*.xlsx'
            provider 'eu.esdihumboldt.hale.io.xls.reader.instance'
            setting 'contentType', 'eu.esdihumboldt.hale.io.xls.xlsx'
            setting 'skip', '1'
            setting 'multiSheet', 'true'
            setting 'dateTimeFormatterDefault', '[dd.MM.yyyy]'
          }

          source(d) {
            include '*.gpkg'
            provider 'eu.esdihumboldt.hale.io.geopackage.instance.reader'
            setting 'contentType', 'eu.esdihumboldt.hale.io.geopackage'
          }
        }
      }

      target(new File(targetFolder, settings.targetFileName ?: 'output.xlsx')) {
        preset 'default'
      }

      printStacktrace = true
      trustGroovy = true
      ignoreExitValue = false

      additionalArgs << '-statisticsOut'
      additionalArgs << "${targetFolder}/statistics.json"
      additionalArgs << '-reportsOut'
      additionalArgs << "${targetFolder}/reports.out"

      description "Validierte Daten auf Basis des hale»studio-Projekts \"${projectFile.name}\" aggregieren."
      group 'Aggregation'
    }

    tasks["aggregate-$name"].doFirst {
      targetFolder.mkdirs()
      FileUtils.cleanDirectory(targetFolder)
    }

    tasks['aggregate-all'].dependsOn("aggregate-$name")
}

config.targetEPSG.each { epsg ->
  config.transformations.each { name, settings ->

    def projectFile = new File(configBasePath, settings.project)

    // target
    String targetName = "$name-$epsg"
    File targetFolder = settings.targetFolder ? new File(configBasePath, settings.targetFolder) : new File('result', targetName)

    task("transform-$name-$epsg", type: hale.transform()) {
      assert projectFile != null
      transformation = projectFile

      settings.shapefiles.each { shapefile ->
        source(new File(configBasePath, shapefile.path)) {
          provider 'eu.esdihumboldt.hale.io.shape.reader.instance'
          include "${shapefile.filename}"
          setting 'contentType', 'eu.esdihumboldt.hale.io.shp'
          setting 'typename', "${shapefile.typename}"
        }
      }

      settings.table.sheets.each { sheet ->
        source(new File(configBasePath, settings.table.path)) {
          provider 'eu.esdihumboldt.hale.io.xls.reader.instance'
          setting 'contentType', 'eu.esdihumboldt.hale.io.xls.xlsx'
          setting 'typename', "${sheet.typename}"
          setting 'sheetIndex', "${sheet.index}"
          setting 'skip', '2'
        }
      }

      if (settings.sourceFilter) {
        filterArgs << '-filter'
        filterArgs << settings.sourceFilter
      }

      logFolder = targetFolder

      target(new File(targetFolder, settings.targetFileName ?: 'output.gpkg')) {
        provider 'eu.esdihumboldt.hale.io.geopackage.instance.writer'

        setting 'crs', "code:EPSG:$epsg"
      }

      // XML schema validation
      // validate('eu.esdihumboldt.hale.io.xml.validator')

      printStacktrace = true
      trustGroovy = true

      // ignore failure -> task will be successful
      ignoreExitValue = true

      description "Runs a transformation based on the project ${projectFile.name}."
      group 'Transformation'
    }

    tasks["transform-$name-$epsg"].doFirst {
      targetFolder.mkdirs()
      FileUtils.cleanDirectory(targetFolder)
    }
    
    tasks['transform-all'].dependsOn("transform-$name-$epsg")
  }
}


configurations.all {
  resolutionStrategy.cacheChangingModulesFor 0, 'seconds'
}

distributions {
  main {
    distributionBaseName = 'uba-end-automation'
    contents {
      from('.') {
        include '*'
        include 'gradle/**'
        exclude '.git'
        exclude '.github'
        exclude '.gitignore'
        exclude '.gradle'
        exclude '.releaserc.yml'
        exclude '.vscode'
        exclude '.wetf-repo.yml'
        exclude '*.log'
        exclude 'gradle.properties'
        exclude 'build/**'
        exclude 'workspace'
      }
    }
  }
}


/*
 * Gradle wrapper
 */
wrapper {
  gradleVersion = '8.10'
}
